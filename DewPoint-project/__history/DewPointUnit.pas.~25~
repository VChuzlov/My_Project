unit DewPointUnit;

interface

uses
  ConvertersUnit, TypesUnit, Math;

type

  TDewPoint = class
    private
      Pressure: double;
      Yi: TArrOfDouble;
      Tc: TArrOfDouble;
      Pc: TArrOfDouble;
      Af: TArrOfDouble;
      Vc: TArrOfDouble;
      Tr: TArrOfDouble;
      Pr: TArrOfDouble;
      Xi: TArrOfDouble;
      Xi_new: TArrOfDouble;
      function CalculateM(af: TArrOfDouble): TArrOfDouble;
      function CalculateAlpha(m, tr: TArrOfDouble): TArrOfDouble;
      function CalculateAp(alpha, tr, pr: TArrOfDouble): TArrOfDouble;
      function CalculateBp(pr, tr: TArrOfDouble): TArrOfDouble;
      function CalculateAi(tc, pc: TArrOfDouble): TArrOfDouble;
      function CalculateBi(tc, pc: TArrOfDouble): TArrOfDouble;
      function CalculateDi(m, ai, alpha, tr: TArrOfDouble): TArrOfDouble;
      function CalculateAb(
        kij: TMatrixOfDouble; ap: TArrOfDouble): TMatrixOfDouble;
      function CalculateAv(y: TArrOfDouble; ab: TMatrixOfDouble): Double;
      function CalculateBv(y, bp: TArrOfDouble): Double;

    public
      constructor Create(
        pressure: double;
        yi: TArrOfDouble;
        tc: TArrOfDouble;
        pc: TArrOfDouble;
        af: TArrOfDouble;
        volc: TArrOfDouble
      );
  end;


implementation

{TDewPoint}

function TDewPoint.CalculateAb(kij: TMatrixOfDouble;
  ap: TArrOfDouble): TMatrixOfDouble;
var
  i: Integer;
  j: Integer;
begin
  SetLength(Result, Length(ap));
  for i := 0 to High(ap) do
    SetLength(Result[i], Length(ap));

  for i := 0 to High(ap) do
    for j := 0 to High(ap) do
      Result[i, j] := (1 - kij[i, j]) * Power(ap[i] * ap[j], 0.5);
end;

function TDewPoint.CalculateAi(tc, pc: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(tc));
  for i := 0 to High(tc) do
    Result[i] := 0.45724 * power(8.314 * tc[i], 2) / pc[i];
end;

function TDewPoint.CalculateAlpha(m, tr: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(m));
  for i := 0 to High(m) do
    Result[i] := Power((1 + m[i] * (1 - Power(tr[i], 0.5))), 2);
end;

function TDewPoint.CalculateAp(alpha, tr, pr: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(alpha));
  for i := 0 to High(alpha) do
    Result[i] := 0.457235529 * alpha[i] * pr[i] / Power(tr[i], 2);
end;

function TDewPoint.CalculateAv(y: TArrOfDouble; ab: TMatrixOfDouble): Double;
var
  i: Integer;
  j: Integer;
begin
  Result := 0.0;
  for i := 0 to High(y) do
    for j := 0 to High(y) do
      Result := Result + y[i] * y[j] * ab[i, j];
end;

function TDewPoint.CalculateBi(tc, pc: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(tc));
  for i := 0 to High(tc) do
    REsult[i] := 0.07780 * 8.314 * tc[i] / pc[i];
end;

function TDewPoint.CalculateBp(pr, tr: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(tr));
  for i := 0 to High(tr) do
    Result[i] := 0.07796074 * pr[i] / tr[i];
end;

function TDewPoint.CalculateBv(y, bp: TArrOfDouble): Double;
var
  i: Integer;
begin
  Result := 0.0;
  for i := 0 to High(y) do
    Result := Result + y[i] * bp[i];
end;

function TDewPoint.CalculateDi(m, ai, alpha, tr: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(m));
  for i := 0 to High(m) do
    Result[i] := m[i] * ai[i] * alpha[i] * Power(tr[i] / alpha[i], 0.5);
end;

function TDewPoint.CalculateM(af: TArrOfDouble): TArrOfDouble;
var
  i: Integer;
begin
  SetLength(Result, Length(af));
  for i := 0 to High(af) do
    if af[i] <= 0.49 then
      Result[i] := 0.3796 + 1.54226 * af[i] - 0.26992 * Power(af[i], 2)
    else
      Result[i] := (
        0.379642 + 1.48503 * af[i]
        - 0.1644 * Power(af[i], 2)
        + 0.016667 * Power(af[i], 3)
      );
end;

constructor TDewPoint.Create(
  pressure: Double;
  yi: TArrOfDouble;
  tc: TArrOfDouble;
  pc: TArrOfDouble;
  af: TArrOfDouble;
  volc: TArrOfDouble
);
var
  uc: TUnitsConverter;
  i: Integer;
begin
  uc := TUnitsConverter.Create();
  self.Pressure := uc.Pressure.kPaToPsi(pressure);
  self.Yi := yi;
  self.Af := af;
  self.Vc := volc;

  SetLength(self.Tc, Length(tc));
  SetLength(self.Pc, Length(pc));
  SetLength(self.Tr, Length(tc));
  SetLength(self.Pr, Length(pc));
  SetLength(self.Xi, Length(yi));
  SetLength(self.Xi_new, Length(yi));

  for i := 0 to High(tc) do
    begin
      self.Tc[i] := uc.Temperature.CelsiusToRankine(tc[i]);
      self.Pc[i] := uc.Pressure.kPaToPsi(pc[i]);
    end;
end;


end.
